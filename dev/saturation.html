<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Saturation problem · Medical Resonance Imaging</title><meta name="title" content="Saturation problem · Medical Resonance Imaging"/><meta property="og:title" content="Saturation problem · Medical Resonance Imaging"/><meta property="twitter:title" content="Saturation problem · Medical Resonance Imaging"/><meta name="description" content="Documentation for Medical Resonance Imaging."/><meta property="og:description" content="Documentation for Medical Resonance Imaging."/><meta property="twitter:description" content="Documentation for Medical Resonance Imaging."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Medical Resonance Imaging</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="bloch-equation.html">Bloch equation</a></li><li class="is-active"><a class="tocitem" href="saturation.html">Saturation problem</a><ul class="internal"><li><a class="tocitem" href="#Time-minimal-saturation-problem"><span>Time-minimal saturation problem</span></a></li><li><a class="tocitem" href="#Direct-method"><span>Direct method</span></a></li><li><a class="tocitem" href="#Indirect-method"><span>Indirect method</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/MedicalResonanceImaging.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/MedicalResonanceImaging.jl/blob/main/docs/src/saturation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="mri-saturation"><a class="docs-heading-anchor" href="#mri-saturation">Saturation problem in Magnetic Resonance Imaging</a><a id="mri-saturation-1"></a><a class="docs-heading-anchor-permalink" href="#mri-saturation" title="Permalink"></a></h1><h2 id="Time-minimal-saturation-problem"><a class="docs-heading-anchor" href="#Time-minimal-saturation-problem">Time-minimal saturation problem</a><a id="Time-minimal-saturation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Time-minimal-saturation-problem" title="Permalink"></a></h2><p>The time-minimal saturation problem is the following: starting from the North pole of the  Bloch ball, the goal is to reach in minimum time the center of the Bloch ball, which  corresponds at the final time to zero magnetization of the spin.</p><div class="admonition is-info" id="Time-minimal-saturation-problem-8c776b10f14bd699"><header class="admonition-header">Time-minimal saturation problem<a class="admonition-anchor" href="#Time-minimal-saturation-problem-8c776b10f14bd699" title="Permalink"></a></header><div class="admonition-body"><p>We define the <em>time-minimal saturation problem</em> as the following optimal control  problem:</p><p class="math-container">\[    \inf t_f, 
    \quad \text{s.t.} \quad u(\cdot) \in \mathcal{U}, \quad 
    t_f \ge 0 \quad \text{and} \quad q(t_f, N, u(\cdot)) = O,\]</p><p>where <span>$N = (0, 1)$</span> is the North pole, where <span>$O = (0,0)$</span> is the origin of the Bloch  ball and where <span>$t \mapsto q(t, q_0, u(\cdot))$</span>  is the unique maximal solution of the 2D control system <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>  associated to the control <span>$u(\cdot)$</span> and starting from the given initial condition <span>$q_0$</span>.</p></div></div><p>The <strong>inversion sequence</strong> <span>${\sigma_+} {\sigma_s^v}$</span>, that is a positive bang arc followed by a singular vertical arc with zero control, is the simplest way to go from <span>$N$</span> to <span>$O$</span>.  Is it optimal?</p><img src="./mri-resources/inversion_sequence.png" style="display: block; margin-left: auto; margin-right: auto;" width="500px">
<br><p>We have the following symmetry.</p><p><strong>Proposition.</strong> Let <span>$(y(\cdot), z(\cdot))$</span>, with associated control <span>$u(\cdot)$</span>, be a  trajectory solution of <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>. Then, <span>$(-y(\cdot), z(\cdot))$</span> with control <span>$-u(\cdot)$</span> is also solution of this system.</p><p>This discrete symmetry allows us to consider only trajectories inside the domain  <span>$\{y \le 0\}$</span> of the Bloch ball.</p><p>In order to solve numerically the problem, we need to set the parameters.  We introduce the practical cases in the following table. We give the relaxation times with  the associated <span>$(\gamma, \Gamma)$</span> parameters for <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz.  Note that in the experiments, <span>$\omega_\mathrm{max}$</span> may be chosen up to 15 000 Hz but we  consider the same value as in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><table><tr><th style="text-align: left"><strong>Name</strong></th><th style="text-align: left"><span>$T_1$</span></th><th style="text-align: left"><span>$T_2$</span></th><th style="text-align: left"><span>$\gamma$</span></th><th style="text-align: left"><span>$\Gamma$</span></th><th style="text-align: left"><span>$\delta=\gamma-\Gamma$</span></th></tr><tr><td style="text-align: left">Water</td><td style="text-align: left">2.5</td><td style="text-align: left">2.5</td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$0.0$</span></td></tr><tr><td style="text-align: left">Cerebrospinal Fluid</td><td style="text-align: left">2.0</td><td style="text-align: left">0.3</td><td style="text-align: left"><span>$2.4637e^{-03}$</span></td><td style="text-align: left"><span>$1.6425e^{-02}$</span></td><td style="text-align: left"><span>$-1.3961^{-02}$</span></td></tr><tr><td style="text-align: left">Deoxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.05</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$9.8548e^{-02}$</span></td><td style="text-align: left"><span>$-9.4898^{-02}$</span></td></tr><tr><td style="text-align: left">Oxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.2</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$-2.0987^{-02}$</span></td></tr><tr><td style="text-align: left">Gray cerebral matter</td><td style="text-align: left">0.92</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$5.3559e^{-03}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-4.3918^{-02}$</span></td></tr><tr><td style="text-align: left">White cerebral matter</td><td style="text-align: left">0.78</td><td style="text-align: left">0.09</td><td style="text-align: left"><span>$6.3172e^{-03}$</span></td><td style="text-align: left"><span>$5.4749e^{-02}$</span></td><td style="text-align: left"><span>$-4.8432^{-02}$</span></td></tr><tr><td style="text-align: left">Fat</td><td style="text-align: left">0.2</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-2.4637^{-02}$</span></td></tr><tr><td style="text-align: left">Brain</td><td style="text-align: left">1.062</td><td style="text-align: left">0.052</td><td style="text-align: left"><span>$4.6397e^{-03}$</span></td><td style="text-align: left"><span>$9.4758e^{-02}$</span></td><td style="text-align: left"><span>$-9.0118^{-02}$</span></td></tr><tr><td style="text-align: left">Parietal muscle</td><td style="text-align: left">1.2</td><td style="text-align: left">0.029</td><td style="text-align: left"><span>$4.1062e^{-03}$</span></td><td style="text-align: left"><span>$1.6991e^{-01}$</span></td><td style="text-align: left"><span>$-1.6580^{-02}$</span></td></tr></table><p>Table: Matter name with associated relaxation times in seconds and relative <span>$(\gamma, \Gamma)$</span> parameters with <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz and <span>$u_\mathrm{max} = 1$</span>.</p><div class="admonition is-info" id="Deoxygenated-blood-case-2b89bcd8da0a2109"><header class="admonition-header">Deoxygenated blood case<a class="admonition-anchor" href="#Deoxygenated-blood-case-2b89bcd8da0a2109" title="Permalink"></a></header><div class="admonition-body"><p>We consider the Deoxygenated blood case.  According to Theorem 3.6 from <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> the optimal solution is of the form  Bang-Singular-Bang-Singular (BSBS). The two bang arcs are with control <span>$u=1$</span>.  The first singular arc is contained in the horizontal line <span>$z=\gamma/2\delta$</span> while the second singular arc is contained in the vertical line <span>$y=0$</span>.  We propose in the following to retrieve this result numerically.</p></div></div><p>Let us first define the parameters with the two vector fields <span>$F_0$</span> and <span>$F_1$</span>.</p><pre><code class="language-julia hljs">import OptimalControl: ⋅
⋅(a::Number, b::Number) = a*b

# Blood case
T1 = 1.35 # s
T2 = 0.05

ω = 2π⋅32.3 # Hz
γ = 1/(ω⋅T1)
Γ = 1/(ω⋅T2)

δ = γ - Γ
zs = γ / 2δ # ordinate of the horizontal singular line

F0(y, z) = [-Γ⋅y, γ⋅(1-z)]
F1(y, z) = [-z, y]

q0 = [0, 1] # initial state: the North pole</code></pre><p>Then, we can define the problem with OptimalControl.</p><pre><code class="language-julia hljs">using OptimalControl

ocp = @def begin

    tf ∈ R, variable
    t ∈ [0, tf ], time
    q = (y, z) ∈ R², state
    u ∈ R, control

    q(0)  == q0
    q(tf) == [0, 0]

    -1 ≤ u(t) ≤ 1

    q̇(t) == F0(q(t)...) + u(t) * F1(q(t)...)

    tf → min

    tf ≥ 0

end</code></pre><h2 id="Direct-method"><a class="docs-heading-anchor" href="#Direct-method">Direct method</a><a id="Direct-method-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-method" title="Permalink"></a></h2><p>We start to solve the problem with a direct method. The problem is transcribed into a NLP optimization problem by OptimalControl. The NLP problem is then solved by the well-known solver Ipopt thanks to NLPModelsIpopt.</p><p>We first start with a coarse grid, with only 50 points. We provide an init to get a solution in the domain <span>$y \le 0$</span>.</p><pre><code class="language-julia hljs">using NLPModelsIpopt

N = 50
sol = solve(ocp; grid_size=N, init=(state=[-0.5, 0.0], ), print_level=4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Total number of variables............................:      154
                     variables with only lower bounds:        1
                variables with lower and upper bounds:       51
                     variables with only upper bounds:        0
Total number of equality constraints.................:      104
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 69

                                   (scaled)                 (unscaled)
Objective...............:   4.3291584173530694e+01    4.3291584173530694e+01
Dual infeasibility......:   5.1199586237338224e-11    5.1199586237338224e-11
Constraint violation....:   1.7602586055431857e-12    1.7602586055431857e-12
Variable bound violation:   9.9810981701864421e-09    9.9810981701864421e-09
Complementarity.........:   2.2437072131224325e-11    2.2437072131224325e-11
Overall NLP error.......:   5.1199586237338224e-11    5.1199586237338224e-11


Number of objective function evaluations             = 85
Number of objective gradient evaluations             = 70
Number of equality constraint evaluations            = 85
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 70
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 69
Total seconds in IPOPT                               = 6.205

EXIT: Optimal Solution Found.</code></pre><p>Then, we plot the solution thanks to Plots.</p><pre><code class="language-julia hljs">using Plots

plt = plot(sol; size=(700, 500), solution_label=&quot;(N = &quot;*string(N)*&quot;)&quot;)</code></pre><img src="saturation-38f8c2e4.svg" alt="Example block output"/><p>This rough approximation is then refine on a finer grid of 500 points. This two steps resolution increases the speed of convergence. Note that we provide the previous solution as initialisation.</p><pre><code class="language-julia hljs">N = 500
direct_sol = solve(ocp; grid_size=N, init=sol, print_level=4, tol=1e-12)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Total number of variables............................:     1504
                     variables with only lower bounds:        1
                variables with lower and upper bounds:      501
                     variables with only upper bounds:        0
Total number of equality constraints.................:     1004
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 11

                                   (scaled)                 (unscaled)
Objective...............:   4.2725098369300866e+01    4.2725098369300866e+01
Dual infeasibility......:   5.6843418860808015e-14    5.6843418860808015e-14
Constraint violation....:   1.1102230246251565e-16    1.1102230246251565e-16
Variable bound violation:   9.9941457332164418e-09    9.9941457332164418e-09
Complementarity.........:   5.0000793557472534e-13    5.0000793557472534e-13
Overall NLP error.......:   5.0000793557472534e-13    5.0000793557472534e-13


Number of objective function evaluations             = 12
Number of objective gradient evaluations             = 12
Number of equality constraint evaluations            = 12
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 12
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 11
Total seconds in IPOPT                               = 0.094

EXIT: Optimal Solution Found.</code></pre><p>We can compare both solutions. The BSBS structure is revelead even if the second bang arc is not clearly  demonstrated.</p><pre><code class="language-julia hljs">plot!(plt, direct_sol; solution_label=&quot;(N = &quot;*string(N)*&quot;)&quot;)</code></pre><img src="saturation-b9221d84.svg" alt="Example block output"/><p>We define a custom plot function to plot the solution inside the Bloch ball.</p><article class="docstring">
<header>
    <a class="docstring-article-toggle-button fa-solid fa-chevron-right" href="javascript:;" title="Expand docstring"> </a>
    <code>spin_plot</code> — <span class="docstring-category">Function</span>
</header>
<section style="display: none;"><div><pre><code class="language-julia hljs">using Plots.PlotMeasures

function spin_plot(sol; kwargs...)

    y2 = cos(asin(zs))
    y1 = -y2

    t = time_grid(sol)
    q = state(sol)
    y = t -> q(t)[1]
    z = t -> q(t)[2]
    u = control(sol)

    # styles
    Bloch_ball_style = (seriestype=[:shape, ], color=:grey, linecolor=:black, 
        legend=false, fillalpha=0.1, aspect_ratio=1)
    axis_style = (color=:black, linewidth=0.5)
    state_style = (label=:none, linewidth=2, color=1)
    initial_point_style = (seriestype=:scatter, color=:1, linewidth=0)
    control_style = (label=:none, linewidth=2, color=1)

    # state trajectory in the Bloch ball
    θ = LinRange(0, 2π, 100)
    state_plt = plot(cos.(θ), sin.(θ); Bloch_ball_style...) # Bloch ball
    plot!(state_plt, [-1, 1], [ 0,  0]; axis_style...)      # horizontal axis 
    plot!(state_plt, [ 0, 0], [-1,  1]; axis_style...)      # vertical axis
    plot!(state_plt, [y1, y2], [zs, zs]; linestyle=:dash, axis_style...) # singular line
    plot!(state_plt, y.(t), z.(t); state_style...)
    plot!(state_plt, [0], [1]; initial_point_style...)
    plot!(state_plt; xlims=(-1.1, 0.1), ylims=(-0.1, 1.1), xlabel="y", ylabel="z")

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # ub
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel="t", ylabel="u")

    return plot(state_plt, control_plt; layout=(1, 2), bottommargin=15px, kwargs...)

end</code><button class="copy-button fa-solid fa-copy" aria-label="Copy this code ;opblock" title="Copy"></button></pre></div>
</section>
</article><p>Below, we plot again the solution but inside the Bloch ball. We can see that the first bang arc permits to reach the horizontal singular line <span>$z=\gamma/2\delta$</span> which is depicted with a dashed line. The second  bang arc is very short which explains why it is not well captured. We may refine the grid around this bang arc to capture it well but in the following we propose to use an indirect method to refine this approximation.</p><pre><code class="language-julia hljs">spin_plot(direct_sol; size=(700, 350))</code></pre><img src="saturation-9071b6cf.svg" alt="Example block output"/><p>To make the indirect method converge we need a good initial guess. We extract below the useful information from the direct solution to provide an initial guess for the indirect method. We need the initial costate together with the switching times between bang and singular arcs and the final time.</p><pre><code class="language-julia hljs">t  = time_grid(direct_sol)
q  = state(direct_sol)
p  = costate(direct_sol)
u  = control(direct_sol)
tf = variable(direct_sol)

t0 = 0
pz0 = p(t0)[2]

t_bang_1 = t[ (abs.(u.(t)) .≥ 0.25) .&amp; (t .≤  5)]
t_bang_2 = t[ (abs.(u.(t)) .≥ 0.25) .&amp; (t .≥ 35)]
t1 = max(t_bang_1...)
t2 = min(t_bang_2...)
t3 = max(t_bang_2...)

q1, p1 = q(t1), p(t1)
q2, p2 = q(t2), p(t2)
q3, p3 = q(t3), p(t3)

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pz0 = -10.134292900434767
t1 = 1.6235537380334328
t2 = 36.230883417167135
t3 = 37.68353676172337
tf = 42.725098369300866</code></pre><h2 id="Indirect-method"><a class="docs-heading-anchor" href="#Indirect-method">Indirect method</a><a id="Indirect-method-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-method" title="Permalink"></a></h2><p>We introduce the pseudo-Hamiltonian</p><p class="math-container">\[H(q, p, u) = H_0(q, p) + u\, H_1(q, p)\]</p><p>where <span>$H_0(q, p) = p \cdot F_0(q)$</span> and <span>$H_1(q, p) = p \cdot F_1(q)$</span> are both Hamiltonian lifts. According to the maximisation condition from the <a href="https://en.wikipedia.org/wiki/Pontryagin%27s_maximum_principle">Pontryagin Maximum Principle</a> (PMP), a bang arc occurs when <span>$H_1$</span> is nonzero and of constant sign along the arc. On the contrary the singular arcs are contained in <span>$H_1 = 0$</span>. If  <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> along an arc then its derivative is also zero. Thus, along a singular arc we have also</p><p class="math-container">\[\frac{\mathrm{d}}{\mathrm{d}t} H_1(q(t), p(t)) = 
\{H_0, H_1\}(q(t), p(t)) = 0,\]</p><p>where <span>$\{H_0, H_1\}$</span> is the Poisson bracket of <span>$H_0$</span> and <span>$H_1$</span>.</p><div class="admonition is-info" id="Lie-and-Poisson-brackets-3e8b7ceb19eced"><header class="admonition-header">Lie and Poisson brackets<a class="admonition-anchor" href="#Lie-and-Poisson-brackets-3e8b7ceb19eced" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$F_0$</span>, <span>$F_1$</span> be two smooth vector fields on a smooth manifold <span>$M$</span> and <span>$f$</span> a smooth function on <span>$M$</span>. Let <span>$x$</span> be local coordinates. The <em>Lie bracket</em> of <span>$F_0$</span> and <span>$F_1$</span> is given by </p><p class="math-container">\[    [F_0,F_1] \coloneqq  F_0 \cdot F_1 - F_1 \cdot F_0,\]</p><p>with <span>$(F_0 \cdot F_1)(x) = \mathrm{d} F_1(x) \cdot F_0(x)$</span>. The <em>Lie derivative</em> <span>$\mathcal{L}_{F_0} f$</span> of <span>$f$</span> along <span>$F_0$</span> is simply written <span>$F_0\cdot f$</span>. Denoting <span>$H_0$</span>, <span>$H_1$</span> the Hamiltonian lifts of <span>$F_0$</span>, <span>$F_1$</span>, then the <em>Poisson bracket</em> of <span>$H_0$</span> and <span>$H_1$</span> is</p><p class="math-container">\[    \{H_0,H_1\}  \coloneqq  \vec{H_0} \cdot H_1.\]</p><p>We also use the notation <span>$H_{01}$</span> (resp. <span>$F_{01}$</span>) to write the bracket <span>$\{H_0,H_1\}$</span> (resp. <span>$[F_0,F_1]$</span>) and so forth. Besides, since <span>$H_0$</span>, <span>$H_1$</span> are Hamiltonian lifts, we have <span>$\{H_0,H_1\}= p \cdot [F_0,F_1]$</span>.</p></div></div><p>We define next a function to plot the switching function <span>$t \mapsto H_1(q(t), p(t))$</span> and its derivative along the solution computed by the direct method.</p><article class="docstring">
<header>
    <a class="docstring-article-toggle-button fa-solid fa-chevron-right" href="javascript:;" title="Expand docstring"> </a>
    <code>switching_plot</code> — <span class="docstring-category">Function</span>
</header>
<section style="display: none;"><div><pre><code class="language-julia hljs">function switching_plot(sol, H1, H01; kwargs...)

    t  = time_grid(sol)
    u  = control(sol)
    q  = state(sol)
    p  = costate(sol)
    tf = t[end]
    φ(t) = H1(q(t), p(t))       # switching function
    dφ(t) = H01(q(t), p(t))     # derivative of the switching function

    # styles
    axis_style = (color=:black, linewidth=0.5, label=false)
    control_style = (label=:none, linewidth=2, color=1)

    # switching function
    switching_plt = plot()
    plot!(switching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(switching_plt, t, φ, label="H1(q(t), p(t))", xlabel="t", linewidth=2)
    plot!(switching_plt; xlims=(0, tf))

    # derivative of the switching function
    dswitching_plt = plot()
    plot!(dswitching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(dswitching_plt, t, dφ, label="H01(q(t), p(t))", xlabel="t", linewidth=2)
    plot!(dswitching_plt; xlims=(0, tf))

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound 
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel="t", ylabel="u")

    return plot(switching_plt, dswitching_plt, control_plt; layout=(3, 1), kwargs...)
end</code><button class="copy-button fa-solid fa-copy" aria-label="Copy this code ;opblock" title="Copy"></button></pre></div>
</section>
</article><p>We can notice on the plots below that maximisation condition from the PMP is not satisfied. We can see that the switching function becomes negative along the first bang arc but there is no switching from the control plot. Besides, we can see that along the first singular arc, the switching function is not always zero.</p><pre><code class="language-julia hljs">H0 = Lift(q -&gt; F0(q...))
H1 = Lift(q -&gt; F1(q...))
H01  = @Lie { H0, H1 }

switching_plot(direct_sol, H1, H01; size=(700, 800))</code></pre><img src="saturation-a4453aea.svg" alt="Example block output"/><p>We aim to compute a better approximation of the solution thanks to indirect shooting. To do so, we need to define the three different flows associated to the three different  control laws in feedback form: bang control, singular control along the horizontal line and singular control along the vertical line. </p><div class="admonition is-info" id="Note-aa38db8b696ba774"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-aa38db8b696ba774" title="Permalink"></a></header><div class="admonition-body"><p>Let us recall that <span>$\delta = \gamma - \Gamma$</span>. Then, for any <span>$q = (y,z)$</span> we have:</p><p class="math-container">\[    \begin{aligned}
        F_{01}(q) &amp;= 
        -(\gamma - \delta z) \frac{\partial}{\partial y} + 
        \delta y \frac{\partial}{\partial z}, \\[0.5em]
        F_{001}(q) &amp;= 
        \left( \gamma\, (\gamma - 2\Gamma) - 
        \delta^2 z\right)\frac{\partial}{ \partial y} + 
        \delta^2 y \frac{\partial}{\partial z}, \\[0.5em]
        F_{101}(q) &amp;= 
        2 \delta y \frac{\partial}{\partial y} + 
        (\gamma - 2 \delta z) \frac{\partial}{\partial z}.
    \end{aligned}\]</p><p>Along a singular arc, we have <span>$H_1 = H_{01} = 0$</span>, that is <span>$p \cdot F_1 = p \cdot F_{01} = 0$</span>. Since, <span>$p$</span> is of dimension 2 and is nonzero, then we have <span>$\det(F_1, F_{01}) = y ( \gamma - 2 \delta z) = 0$</span>. This gives us the two singular lines. </p><p>Differentiating <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> a second time along a singular arc gives</p><p class="math-container">\[    H_{001}(q(t), p(t)) + u(t)\, H_{101}(q(t), p(t)) = 0,\]</p><p>that is <span>$p(t)$</span> is orthogonal to <span>$F_{001}(q(t)) + u(t)\, F_{101}(q(t))$</span>. Hence, the singular control is given by</p><p class="math-container">\[    \det(F_1(q(t)), F_{001}(q(t))) + u(t) \, \det(F_1(q(t)), F_{101}(q(t))) = 0.\]</p><p>For <span>$y=0$</span>, <span>$\det(F_1(q), F_{101}(q))$</span> is zero and thus the singular control is zero. We denote it <span>$u_0 \coloneqq 0$</span>. Along the horizontal singular line, that is for <span>$z=\gamma/2\delta$</span>,  the control is given by </p><p class="math-container">\[    u_s(y) \coloneqq \gamma (2\Gamma - \gamma) / (2 \delta y).\]</p><p>Note that we could have defined the singular control with the Hamiltonian lifts <span>$H_{001}$</span> and <span>$H_{101}$</span>. See the <a href="https://control-toolbox.org/docs/optimalcontrol/stable/tutorial-goddard.html#Indirect-method">Goddard tutorial</a> for an example of such a computation.</p></div></div><pre><code class="language-julia hljs">using OrdinaryDiffEq

# Controls
u0 = 0                   # off control: vertical singular line
u1 = 1                   # positive bang control
us(y) = γ⋅(2Γ−γ)/(2δ⋅y)  # singular control: horizontal line

# Flows
tolerances = (abstol=1e-14, reltol=1e-10)

f0 = Flow(ocp, (q, p, tf) -&gt; u0      ; tolerances...)
f1 = Flow(ocp, (q, p, tf) -&gt; u1      ; tolerances...)
fs = Flow(ocp, (q, p, tf) -&gt; us(q[1]); tolerances...)</code></pre><p>With the previous flows, we can define the shooting function considering the sequence Bang-Singular-Bang-Singular. There are 3 switching times <span>$t_1$</span>, <span>$t_2$</span> and <span>$t_3$</span>. The final time <span>$t_f$</span> is unknown such as the initial costate. To reduce the sensitivy of the shooting function we also consider the states and costates at the switching times as unknowns and we add some matching conditions.</p><p>Note that the final time is free, hence, in the normal case, <span>$H = -p^0 = 1$</span> along the solution of the PMP. Considering this condition at the initial time, we obtain <span>$p_y(0) = -1$</span>. At the entrance of the singular arcs, we must satisfy <span>$H_1 = H_{01} = 0$</span>. For the first singular arc, this leads to the conditions </p><p class="math-container">\[    - p_y(t_1) z_s + p_z(t_1) y(t_1) = z(t_1) - z_s = 0.\]</p><p>At the entrance of the second singular arc, we have</p><p class="math-container">\[    p_y(t_3) = y(t_3) = 0.\]</p><p>Finally, the solution has to satisfy the final condition  <span>$q(t_f) = (y(t_f), z(t_f)) = (0, 0)$</span>. Since, the last singular arc is contained in <span>$y=0$</span>, the condition <span>$y(t_f)=0$</span> is redundant and  so we only need to check that <span>$z(t_f) = 0$</span>.</p><p>Altogether, this leads to the following shooting function.</p><pre><code class="language-julia hljs">function shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

    p0 = [-1, pz0]

    q1_, p1_ = f1(t0, q0, p0, t1)
    q2_, p2_ = fs(t1, q1, p1, t2)
    q3_, p3_ = f1(t2, q2, p2, t3)
    qf , pf  = f0(t3, q3, p3, tf)

    s[1] = - p1[1] ⋅ zs + p1[2] ⋅ q1[1]   # H1 = H01 = 0 on the horizontal
    s[2] = q1[2] - zs                     # singular line, z=zs
    s[3] = p3[1]                          # H1 = H01 = 0 on the vertical
    s[4] = q3[1]                          # singular line, y=0
    s[5] = qf[2]                          # z(tf) = 0

    # matching conditions
    s[ 6: 7] = q1 - q1_
    s[ 8: 9] = p1 - p1_
    s[10:11] = q2 - q2_
    s[12:13] = p2 - p2_
    s[14:15] = q3 - q3_
    s[16:17] = p3 - p3_

end</code></pre><p>We are now in position to solve the shooting equations. Due to the sensitivity of the first singular arc, we need to improve the initial guess obtained from the direct method to make the Newton solver converge. To do so, we set for the initial guess <span>$z(t_1) = z_s$</span> and <span>$p_z(t_1) = p_y(t_1) z_s / y(t_1)$</span>.</p><p>We can see below from the norm of the shooting function that the initial guess is not very accurate.</p><pre><code class="language-julia hljs"># we refine the initial guess to make the Newton solver converge
q1[2] = zs
p1[2] = p1[1] ⋅ zs / q1[1]

# Norm of the shooting function at initial guess
using LinearAlgebra: norm

s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Norm of the shooting function: ‖s‖ = 229.62197090151722</code></pre><p>Finally, we can solve the shooting equations thanks to <a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve</a> and improve our solution.</p><pre><code class="language-julia hljs">using NonlinearSolve

# auxiliary function with aggregated inputs
nle = (s, ξ, λ) -&gt; shoot!(s, ξ[1], ξ[2:5]..., ξ[6:7], ξ[8:9],
                            ξ[10:11], ξ[12:13], ξ[14:15], ξ[16:17])

# initial guess
ξ = [ pz0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3]

# NLE problem
prob = NonlinearProblem(nle, ξ)

# resolution of S=0
indirect_sol = NonlinearSolve.solve(prob, SimpleNewtonRaphson(); abstol=1e-8, reltol=1e-8, show_trace=Val(true))

# we retrieve the costate solution together with the times
pz0 = indirect_sol.u[1]
t1 = indirect_sol.u[2]
t2 = indirect_sol.u[3]
t3 = indirect_sol.u[4]
tf = indirect_sol.u[5]
q1 = indirect_sol.u[6:7]
p1 = indirect_sol.u[8:9]
q2 = indirect_sol.u[10:11]
p2 = indirect_sol.u[12:13]
q3 = indirect_sol.u[14:15]
p3 = indirect_sol.u[16:17]

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)

# Norm of the shooting function at solution
s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pz0 = -10.103027162172832
t1 = 1.6450509469600774
t2 = 37.32398128558377
t3 = 37.58077357861781
tf = 42.7137087536317
Norm of the shooting function: ‖s‖ = 1.5896820623393179e-12</code></pre><p>Let us plot the solution from the indirect method. We can notice that the second bang arc is well captured by the indirect method compared to the direct method.</p><pre><code class="language-julia hljs"># concatenation of the flows with the switching times
f = f1 * (t1, fs) * (t2, f1) * (t3, f0)

# computation of the solution: state, costate, control
indirect_sol = f((t0, tf), q0, [-1, pz0])

# plot in the Bloch ball
spin_plot(indirect_sol; size=(700, 350))</code></pre><img src="saturation-c4ba2fd7.svg" alt="Example block output"/><p>From the following plot, we can conclude that the maximisation condition from the PMP is now well satisfied compared to the solution obtained from the direct method.</p><pre><code class="language-julia hljs">switching_plot(indirect_sol, H1, H01; size=(700, 800))</code></pre><img src="saturation-1ba46597.svg" alt="Example block output"/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>B. Bonnard, O. Cots, S. Glaser, M. Lapert, D. Sugny &amp; Y. Zhang, *Geometric optimal control of the contrast imaging problem in nuclear magnetic resonance, IEEE Trans. Automat. Control, <strong>57</strong> (2012), no. 8, 1957–1969.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bonnard, B.; Cots, O.; Rouot, J.; Verron, T. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88. https://inria.hal.science/hal-01779377</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="bloch-equation.html">« Bloch equation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 24 July 2025 15:34">Thursday 24 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
