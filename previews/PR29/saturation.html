<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Saturation problem · Magnetic Resonance Imaging</title><meta name="title" content="Saturation problem · Magnetic Resonance Imaging"/><meta property="og:title" content="Saturation problem · Magnetic Resonance Imaging"/><meta property="twitter:title" content="Saturation problem · Magnetic Resonance Imaging"/><meta name="description" content="Documentation for Magnetic Resonance Imaging."/><meta property="og:description" content="Documentation for Magnetic Resonance Imaging."/><meta property="twitter:description" content="Documentation for Magnetic Resonance Imaging."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://control-toolbox.org/assets/css/documentation.css" rel="stylesheet" type="text/css"/><script src="https://control-toolbox.org/assets/js/documentation.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Magnetic Resonance Imaging</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="bloch-equation.html">Bloch equation</a></li><li class="is-active"><a class="tocitem" href="saturation.html">Saturation problem</a><ul class="internal"><li><a class="tocitem" href="#Time-minimal-saturation-problem"><span>Time-minimal saturation problem</span></a></li><li><a class="tocitem" href="#Direct-method"><span>Direct method</span></a></li><li><a class="tocitem" href="#Indirect-method"><span>Indirect method</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="saturation.html">Saturation problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/MagneticResonanceImaging.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/MagneticResonanceImaging.jl/blob/main/docs/src/saturation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="mri-saturation"><a class="docs-heading-anchor" href="#mri-saturation">Saturation problem in Magnetic Resonance Imaging</a><a id="mri-saturation-1"></a><a class="docs-heading-anchor-permalink" href="#mri-saturation" title="Permalink"></a></h1><h2 id="Time-minimal-saturation-problem"><a class="docs-heading-anchor" href="#Time-minimal-saturation-problem">Time-minimal saturation problem</a><a id="Time-minimal-saturation-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Time-minimal-saturation-problem" title="Permalink"></a></h2><p>The time-minimal saturation problem is the following: starting from the North pole of the  Bloch ball, the goal is to reach in minimum time the center of the Bloch ball, which  corresponds at the final time to zero magnetization of the spin.</p><div class="admonition is-info" id="Time-minimal-saturation-problem-8c776b10f14bd699"><header class="admonition-header">Time-minimal saturation problem<a class="admonition-anchor" href="#Time-minimal-saturation-problem-8c776b10f14bd699" title="Permalink"></a></header><div class="admonition-body"><p>We define the <em>time-minimal saturation problem</em> as the following optimal control  problem:</p><p class="math-container">\[    \inf t_f, 
    \quad \text{s.t.} \quad u(\cdot) \in \mathcal{U}, \quad 
    t_f \ge 0 \quad \text{and} \quad q(t_f, N, u(\cdot)) = O,\]</p><p>where <span>$N = (0, 1)$</span> is the North pole, where <span>$O = (0,0)$</span> is the origin of the Bloch  ball and where <span>$t \mapsto q(t, q_0, u(\cdot))$</span>  is the unique maximal solution of the 2D control system <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>  associated to the control <span>$u(\cdot)$</span> and starting from the given initial condition <span>$q_0$</span>.</p></div></div><p>The <strong>inversion sequence</strong> <span>${\sigma_+} {\sigma_s^v}$</span>, that is a positive bang arc followed by a singular vertical arc with zero control, is the simplest way to go from <span>$N$</span> to <span>$O$</span>.  Is it optimal?</p><img src="./mri-resources/inversion_sequence.png" style="display: block; margin-left: auto; margin-right: auto;" width="500px">
<br><p>We have the following symmetry.</p><p><strong>Proposition.</strong> Let <span>$(y(\cdot), z(\cdot))$</span>, with associated control <span>$u(\cdot)$</span>, be a  trajectory solution of <span>$\dot{q} = F_0(q) + u\, F_1(q)$</span>. Then, <span>$(-y(\cdot), z(\cdot))$</span> with control <span>$-u(\cdot)$</span> is also solution of this system.</p><p>This discrete symmetry allows us to consider only trajectories inside the domain  <span>$\{y \le 0\}$</span> of the Bloch ball.</p><p>In order to solve numerically the problem, we need to set the parameters.  We introduce the practical cases in the following table. We give the relaxation times with  the associated <span>$(\gamma, \Gamma)$</span> parameters for <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz.  Note that in the experiments, <span>$\omega_\mathrm{max}$</span> may be chosen up to 15 000 Hz but we  consider the same value as in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><table><tr><th style="text-align: left"><strong>Name</strong></th><th style="text-align: left"><span>$T_1$</span></th><th style="text-align: left"><span>$T_2$</span></th><th style="text-align: left"><span>$\gamma$</span></th><th style="text-align: left"><span>$\Gamma$</span></th><th style="text-align: left"><span>$\delta=\gamma-\Gamma$</span></th></tr><tr><td style="text-align: left">Water</td><td style="text-align: left">2.5</td><td style="text-align: left">2.5</td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$1.9710e^{-03}$</span></td><td style="text-align: left"><span>$0.0$</span></td></tr><tr><td style="text-align: left">Cerebrospinal Fluid</td><td style="text-align: left">2.0</td><td style="text-align: left">0.3</td><td style="text-align: left"><span>$2.4637e^{-03}$</span></td><td style="text-align: left"><span>$1.6425e^{-02}$</span></td><td style="text-align: left"><span>$-1.3961^{-02}$</span></td></tr><tr><td style="text-align: left">Deoxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.05</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$9.8548e^{-02}$</span></td><td style="text-align: left"><span>$-9.4898^{-02}$</span></td></tr><tr><td style="text-align: left">Oxygenated blood</td><td style="text-align: left">1.35</td><td style="text-align: left">0.2</td><td style="text-align: left"><span>$3.6499e^{-03}$</span></td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$-2.0987^{-02}$</span></td></tr><tr><td style="text-align: left">Gray cerebral matter</td><td style="text-align: left">0.92</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$5.3559e^{-03}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-4.3918^{-02}$</span></td></tr><tr><td style="text-align: left">White cerebral matter</td><td style="text-align: left">0.78</td><td style="text-align: left">0.09</td><td style="text-align: left"><span>$6.3172e^{-03}$</span></td><td style="text-align: left"><span>$5.4749e^{-02}$</span></td><td style="text-align: left"><span>$-4.8432^{-02}$</span></td></tr><tr><td style="text-align: left">Fat</td><td style="text-align: left">0.2</td><td style="text-align: left">0.1</td><td style="text-align: left"><span>$2.4637e^{-02}$</span></td><td style="text-align: left"><span>$4.9274e^{-02}$</span></td><td style="text-align: left"><span>$-2.4637^{-02}$</span></td></tr><tr><td style="text-align: left">Brain</td><td style="text-align: left">1.062</td><td style="text-align: left">0.052</td><td style="text-align: left"><span>$4.6397e^{-03}$</span></td><td style="text-align: left"><span>$9.4758e^{-02}$</span></td><td style="text-align: left"><span>$-9.0118^{-02}$</span></td></tr><tr><td style="text-align: left">Parietal muscle</td><td style="text-align: left">1.2</td><td style="text-align: left">0.029</td><td style="text-align: left"><span>$4.1062e^{-03}$</span></td><td style="text-align: left"><span>$1.6991e^{-01}$</span></td><td style="text-align: left"><span>$-1.6580^{-02}$</span></td></tr></table><p>Table: Matter name with associated relaxation times in seconds and relative <span>$(\gamma, \Gamma)$</span> parameters with <span>$\omega_\mathrm{max} = 2 \pi\times 32.3$</span> Hz and <span>$u_\mathrm{max} = 1$</span>.</p><div class="admonition is-info" id="Deoxygenated-blood-case-2b89bcd8da0a2109"><header class="admonition-header">Deoxygenated blood case<a class="admonition-anchor" href="#Deoxygenated-blood-case-2b89bcd8da0a2109" title="Permalink"></a></header><div class="admonition-body"><p>We consider the Deoxygenated blood case.  According to Theorem 3.6 from <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> the optimal solution is of the form  Bang-Singular-Bang-Singular (BSBS). The two bang arcs are with control <span>$u=1$</span>.  The first singular arc is contained in the horizontal line <span>$z=\gamma/2\delta$</span> while the second singular arc is contained in the vertical line <span>$y=0$</span>.  We propose in the following to retrieve this result numerically.</p></div></div><p>Let us first define the parameters with the two vector fields <span>$F_0$</span> and <span>$F_1$</span>.</p><pre><code class="language-julia hljs">import OptimalControl: ⋅
⋅(a::Number, b::Number) = a*b

# Blood case
T1 = 1.35 # s
T2 = 0.05

ω = 2π⋅32.3 # Hz
γ = 1/(ω⋅T1)
Γ = 1/(ω⋅T2)

δ = γ - Γ
zs = γ / 2δ # ordinate of the horizontal singular line

F0(y, z) = [-Γ⋅y, γ⋅(1-z)]
F1(y, z) = [-z, y]

q0 = [0, 1] # initial state: the North pole</code></pre><p>Then, we can define the problem with OptimalControl.</p><pre><code class="language-julia hljs">using OptimalControl

ocp = @def begin

    tf ∈ R, variable
    t ∈ [0, tf ], time
    q = (y, z) ∈ R², state
    u ∈ R, control

    y(t) ≤ 0.1 # for the symmetry

    q(0)  == q0
    q(tf) == [0, 0]

    -1 ≤ u(t) ≤ 1

    q̇(t) == F0(q(t)...) + u(t) * F1(q(t)...)

    tf → min

    tf ≥ 0

end</code></pre><h2 id="Direct-method"><a class="docs-heading-anchor" href="#Direct-method">Direct method</a><a id="Direct-method-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-method" title="Permalink"></a></h2><p>We start to solve the problem with a direct method. The problem is transcribed into a NLP optimization problem by OptimalControl. The NLP problem is then solved by the well-known solver Ipopt thanks to NLPModelsIpopt.</p><p>We first start with a coarse grid, with only 100 points. We provide an init consistent with a solution in the domain <span>$y \le 0$</span>.</p><pre><code class="language-julia hljs">using NLPModelsIpopt
N = 100
sol = solve(
    ocp;
    grid_size=N,
    init=(state=[-0.5, 0.0], ),
    disc_method=:gauss_legendre_2,
    print_level=4
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">▫ This is OptimalControl version v1.1.6 running with: direct, adnlp, ipopt.

▫ The optimal control problem is solved with CTDirect version v0.17.4.

   ┌─ The NLP is modelled with ADNLPModels and solved with NLPModelsIpopt.
   │
   ├─ Number of time steps⋅: 100
   └─ Discretisation scheme: gauss_legendre_2

Total number of variables............................:      703
                     variables with only lower bounds:        1
                variables with lower and upper bounds:      100
                     variables with only upper bounds:      101
Total number of equality constraints.................:      604
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 143

                                   (scaled)                 (unscaled)
Objective...............:   4.2714529345077786e+01    4.2714529345077786e+01
Dual infeasibility......:   7.2743894241611429e-13    7.2743894241611429e-13
Constraint violation....:   1.1102230246251565e-16    1.1102230246251565e-16
Variable bound violation:   9.9751860105357082e-09    9.9751860105357082e-09
Complementarity.........:   1.0000006641016691e-11    1.0000006641016691e-11
Overall NLP error.......:   1.0000006641016691e-11    1.0000006641016691e-11


Number of objective function evaluations             = 209
Number of objective gradient evaluations             = 133
Number of equality constraint evaluations            = 209
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 149
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 143
Total seconds in IPOPT                               = 7.750

EXIT: Optimal Solution Found.</code></pre><p>Then, we plot the solution thanks to Plots.</p><pre><code class="language-julia hljs">using Plots
plt = plot(sol; size=(700, 500), label=&quot;N = &quot;*string(N))</code></pre><img src="saturation-29ac4648.svg" alt="Example block output"/><p>This rough approximation is then refine on a finer grid of 1000 points. This two steps resolution increases the speed of convergence. Note that we provide the previous solution as initialisation.</p><pre><code class="language-julia hljs">N = 1000
direct_sol = solve(
    ocp;
    grid_size=N,
    init=sol,
    disc_method=:gauss_legendre_2,
    print_level=4,
    tol=1e-12
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">▫ This is OptimalControl version v1.1.6 running with: direct, adnlp, ipopt.

▫ The optimal control problem is solved with CTDirect version v0.17.4.

   ┌─ The NLP is modelled with ADNLPModels and solved with NLPModelsIpopt.
   │
   ├─ Number of time steps⋅: 1000
   └─ Discretisation scheme: gauss_legendre_2

Total number of variables............................:     7003
                     variables with only lower bounds:        1
                variables with lower and upper bounds:     1000
                     variables with only upper bounds:     1001
Total number of equality constraints.................:     6004
Total number of inequality constraints...............:        0
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0


Number of Iterations....: 55

                                   (scaled)                 (unscaled)
Objective...............:   4.2713711084173745e+01    4.2713711084173745e+01
Dual infeasibility......:   9.6456176379433600e-13    9.6456176379433600e-13
Constraint violation....:   2.7755575615628914e-16    2.7755575615628914e-16
Variable bound violation:   9.9883199489170238e-09    9.9883199489170238e-09
Complementarity.........:   5.0000406364690906e-13    5.0000406364690906e-13
Overall NLP error.......:   9.6456176379433600e-13    9.6456176379433600e-13


Number of objective function evaluations             = 79
Number of objective gradient evaluations             = 56
Number of equality constraint evaluations            = 79
Number of inequality constraint evaluations          = 0
Number of equality constraint Jacobian evaluations   = 57
Number of inequality constraint Jacobian evaluations = 0
Number of Lagrangian Hessian evaluations             = 55
Total seconds in IPOPT                               = 3.321

EXIT: Optimal Solution Found.</code></pre><p>We can compare both solutions. The BSBS structure is revealed even if the second bang arc is not clearly demonstrated.</p><pre><code class="language-julia hljs">plot!(plt, direct_sol; label=&quot;N = &quot;*string(N), color=2)</code></pre><img src="saturation-8fbda2ba.svg" alt="Example block output"/><div class="admonition is-info" id="Code-for-plotting-in-the-Bloch-ball-62e42b27420c2159"><header class="admonition-header">Code for plotting in the Bloch ball<a class="admonition-anchor" href="#Code-for-plotting-in-the-Bloch-ball-62e42b27420c2159" title="Permalink"></a></header><div class="admonition-body"><p>We define a custom plot function for plotting the solution inside the Bloch ball.</p><details><summary>Click to unfold and get the code of the custom plot function.</summary><pre><code class="language-julia hljs">using Plots.PlotMeasures
function spin_plot(sol; kwargs...)

    y2 = cos(asin(zs))
    y1 = -y2

    t = time_grid(sol)
    q = state(sol)
    y = t -&gt; q(t)[1]
    z = t -&gt; q(t)[2]
    u = control(sol)

    # styles
    Bloch_ball_style = (seriestype=[:shape, ], color=:grey, linecolor=:black,
        legend=false, fillalpha=0.1, aspect_ratio=1)
    state_style = (label=:none, linewidth=2, color=1)
    initial_point_style = (seriestype=:scatter, color=:1, linewidth=0)
    axis_style = (color=:black, linewidth=0.5)
    control_style = (label=:none, linewidth=2, color=1)

    # state trajectory in the Bloch ball
    θ = LinRange(0, 2π, 100)
    state_plt = plot(cos.(θ), sin.(θ); Bloch_ball_style...) # Bloch ball
    plot!(state_plt, [-1, 1], [ 0,  0]; axis_style...)      # horizontal axis
    plot!(state_plt, [ 0, 0], [-1,  1]; axis_style...)      # vertical axis
    plot!(state_plt, [y1, y2], [zs, zs]; linestyle=:dash, axis_style...) # singular line
    plot!(state_plt, y.(t), z.(t); state_style...)
    plot!(state_plt, [0], [1]; initial_point_style...)
    plot!(state_plt; xlims=(-1.1, 0.1), ylims=(-0.1, 1.1), xlabel=&quot;y&quot;, ylabel=&quot;z&quot;)

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

    return plot(state_plt, control_plt; layout=(1, 2), leftmargin=15px, bottommargin=15px, kwargs...)

end</code></pre></details></div></div><p>Below, we plot the solution inside the Bloch ball. The first bang arc drives the trajectory to the horizontal singular line <span>$z = \gamma / (2\delta)$</span>, shown as a dashed line. The second bang arc is very short, which makes it difficult to capture accurately unless the grid is sufficiently fine. In the next section, we introduce an indirect method to refine this approximation.</p><pre><code class="language-julia hljs">spin_plot(direct_sol; size=(800, 400))</code></pre><img src="saturation-29dcf854.svg" alt="Example block output"/><p>To make the indirect method converge we need a good initial guess. We extract below the useful information from the direct solution to provide an initial guess for the indirect method. We need the initial costate together with the switching times between bang and singular arcs and the final time.</p><pre><code class="language-julia hljs">t  = time_grid(direct_sol)
q  = state(direct_sol)
p  = costate(direct_sol)
u  = control(direct_sol)
tf = variable(direct_sol)

t0 = 0
pz0 = p(t0)[2]

t_bang_1 = t[ (abs.(u.(t)) .≥ 0.5) .&amp; (t .≤  5)]
t_bang_2 = t[ (abs.(u.(t)) .≥ 0.5) .&amp; (t .≥ 35)]
t1 = max(t_bang_1...)
t2 = min(t_bang_2...)
t3 = max(t_bang_2...)

q1, p1 = q(t1), p(t1)
q2, p2 = q(t2), p(t2)
q3, p3 = q(t3), p(t3)

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">pz0 = -10.138145104720211
t1 = 1.6231210211986022
t2 = 37.118214932146984
t3 = 37.545352042988725
tf = 42.713711084173745</code></pre><h2 id="Indirect-method"><a class="docs-heading-anchor" href="#Indirect-method">Indirect method</a><a id="Indirect-method-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-method" title="Permalink"></a></h2><p>We introduce the pseudo-Hamiltonian</p><p class="math-container">\[H(q, p, u) = H_0(q, p) + u\, H_1(q, p)\]</p><p>where <span>$H_0(q, p) = p \cdot F_0(q)$</span> and <span>$H_1(q, p) = p \cdot F_1(q)$</span> are both Hamiltonian lifts. According to the maximisation condition from the <a href="https://en.wikipedia.org/wiki/Pontryagin%27s_maximum_principle">Pontryagin Maximum Principle</a> (PMP), a bang arc occurs when <span>$H_1$</span> is nonzero and of constant sign along the arc. On the contrary the singular arcs are contained in <span>$H_1 = 0$</span>. If  <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> along an arc then its derivative is also zero. Thus, along a singular arc we have also</p><p class="math-container">\[\frac{\mathrm{d}}{\mathrm{d}t} H_1(q(t), p(t)) = 
\{H_0, H_1\}(q(t), p(t)) = 0,\]</p><p>where <span>$\{H_0, H_1\}$</span> is the Poisson bracket of <span>$H_0$</span> and <span>$H_1$</span>.</p><div class="admonition is-info" id="Lie-and-Poisson-brackets-3e8b7ceb19eced"><header class="admonition-header">Lie and Poisson brackets<a class="admonition-anchor" href="#Lie-and-Poisson-brackets-3e8b7ceb19eced" title="Permalink"></a></header><div class="admonition-body"><p>Let <span>$F_0$</span>, <span>$F_1$</span> be two smooth vector fields on a smooth manifold <span>$M$</span> and <span>$f$</span> a smooth function on <span>$M$</span>. Let <span>$x$</span> be local coordinates. The <em>Lie bracket</em> of <span>$F_0$</span> and <span>$F_1$</span> is given by </p><p class="math-container">\[    [F_0,F_1] \coloneqq  F_0 \cdot F_1 - F_1 \cdot F_0,\]</p><p>with <span>$(F_0 \cdot F_1)(x) = \mathrm{d} F_1(x) \cdot F_0(x)$</span>. The <em>Lie derivative</em> <span>$\mathcal{L}_{F_0} f$</span> of <span>$f$</span> along <span>$F_0$</span> is simply written <span>$F_0\cdot f$</span>. Denoting <span>$H_0$</span>, <span>$H_1$</span> the Hamiltonian lifts of <span>$F_0$</span>, <span>$F_1$</span>, then the <em>Poisson bracket</em> of <span>$H_0$</span> and <span>$H_1$</span> is</p><p class="math-container">\[    \{H_0,H_1\}  \coloneqq  \vec{H_0} \cdot H_1.\]</p><p>We also use the notation <span>$H_{01}$</span> (resp. <span>$F_{01}$</span>) to write the bracket <span>$\{H_0,H_1\}$</span> (resp. <span>$[F_0,F_1]$</span>) and so forth. Besides, since <span>$H_0$</span>, <span>$H_1$</span> are Hamiltonian lifts, we have <span>$\{H_0,H_1\}= p \cdot [F_0,F_1]$</span>.</p></div></div><div class="admonition is-info" id="Code-for-plotting-the-switching-function-and-its-derivative-621ab70bd8b22c14"><header class="admonition-header">Code for plotting the switching function and its derivative<a class="admonition-anchor" href="#Code-for-plotting-the-switching-function-and-its-derivative-621ab70bd8b22c14" title="Permalink"></a></header><div class="admonition-body"><p>We define a function for plotting the switching function <span>$t \mapsto H_1(q(t), p(t))$</span> and its derivative along the solution computed by the direct method.</p><details><summary>Click to unfold and get the code of the function.</summary><pre><code class="language-julia hljs">function switching_plot(sol, H1, H01; kwargs...)

    t  = time_grid(sol)
    u  = control(sol)
    q  = state(sol)
    p  = costate(sol)
    tf = t[end]
    φ(t) = H1(q(t), p(t))       # switching function
    dφ(t) = H01(q(t), p(t))     # derivative of the switching function

    # styles
    axis_style = (color=:black, linewidth=0.5, label=false)
    control_style = (label=:none, linewidth=2, color=1)

    # switching function
    switching_plt = plot()
    plot!(switching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(switching_plt, t, φ, label=&quot;H1(q(t), p(t))&quot;, xlabel=&quot;t&quot;, linewidth=2)
    plot!(switching_plt; xlims=(0, tf))

    # derivative of the switching function
    dswitching_plt = plot()
    plot!(dswitching_plt, [0, tf], [0, 0]; axis_style...)
    plot!(dswitching_plt, t, dφ, label=&quot;H01(q(t), p(t))&quot;, xlabel=&quot;t&quot;, linewidth=2)
    plot!(dswitching_plt; xlims=(0, tf))

    # control
    control_plt = plot(legend=false)
    plot!(control_plt, [ 0, t[end]], [1,  1]; linestyle=:dash, axis_style...) # upper bound
    plot!(control_plt, [ 0, t[end]], [0,  0]; linestyle=:dash, axis_style...)
    plot!(control_plt, [ 0, 0], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, [ t[end], t[end]], [-0.1,  1.1]; axis_style...)
    plot!(control_plt, t, u.(t); control_style...)
    plot!(control_plt; ylims=(-0.1, 1.1), xlabel=&quot;t&quot;, ylabel=&quot;u&quot;)

    return plot(switching_plt, dswitching_plt, control_plt; layout=(3, 1), kwargs...)
end</code></pre></details></div></div><p>We can notice on the plots below that maximisation condition from the PMP is not satisfied. We can see that the switching function becomes negative along the first bang arc but there is no switching from the control plot. Besides, we can see that along the first singular arc, the switching function is not always zero.</p><pre><code class="language-julia hljs">H0 = Lift(q -&gt; F0(q...))
H1 = Lift(q -&gt; F1(q...))
H01  = @Lie { H0, H1 }

switching_plot(direct_sol, H1, H01; size=(700, 800))</code></pre><img src="saturation-19c8adc6.svg" alt="Example block output"/><p>We aim to compute a better approximation of the solution thanks to indirect shooting. To do so, we need to define the three different flows associated to the three different  control laws in feedback form: bang control, singular control along the horizontal line and singular control along the vertical line. </p><div class="admonition is-info" id="Note-7eb04a3bb9d48c15"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7eb04a3bb9d48c15" title="Permalink"></a></header><div class="admonition-body"><p>Let us recall that <span>$\delta = \gamma - \Gamma$</span>. Then, for any <span>$q = (y,z)$</span> we have:</p><p class="math-container">\[    \begin{aligned}
        F_{01}(q) &amp;= 
        -(\gamma - \delta z) \frac{\partial}{\partial y} + 
        \delta y \frac{\partial}{\partial z}, \\[0.5em]
        F_{001}(q) &amp;= 
        \left( \gamma\, (\gamma - 2\Gamma) - 
        \delta^2 z\right)\frac{\partial}{ \partial y} + 
        \delta^2 y \frac{\partial}{\partial z}, \\[0.5em]
        F_{101}(q) &amp;= 
        2 \delta y \frac{\partial}{\partial y} + 
        (\gamma - 2 \delta z) \frac{\partial}{\partial z}.
    \end{aligned}\]</p><p>Along a singular arc, we have <span>$H_1 = H_{01} = 0$</span>, that is <span>$p \cdot F_1 = p \cdot F_{01} = 0$</span>. Since, <span>$p$</span> is of dimension 2 and is nonzero, then we have <span>$\det(F_1, F_{01}) = y ( \gamma - 2 \delta z) = 0$</span>. This gives us the two singular lines. </p><p>Differentiating <span>$t \mapsto H_1(q(t), p(t)) = 0$</span> a second time along a singular arc gives</p><p class="math-container">\[    H_{001}(q(t), p(t)) + u(t)\, H_{101}(q(t), p(t)) = 0,\]</p><p>that is <span>$p(t)$</span> is orthogonal to <span>$F_{001}(q(t)) + u(t)\, F_{101}(q(t))$</span>. Hence, the singular control is given by</p><p class="math-container">\[    \det(F_1(q(t)), F_{001}(q(t))) + u(t) \, \det(F_1(q(t)), F_{101}(q(t))) = 0.\]</p><p>For <span>$y=0$</span>, <span>$\det(F_1(q), F_{101}(q))$</span> is zero and thus the singular control is zero. We denote it <span>$u_0 \coloneqq 0$</span>. Along the horizontal singular line, that is for <span>$z=\gamma/2\delta$</span>,  the control is given by </p><p class="math-container">\[    u_s(y) \coloneqq \gamma (2\Gamma - \gamma) / (2 \delta y).\]</p><p>Note that we could have defined the singular control with the Hamiltonian lifts <span>$H_{001}$</span> and <span>$H_{101}$</span>. See the <a href="https://control-toolbox.org/Tutorials.jl/stable/tutorial-goddard.html">Goddard tutorial</a> for an example of such a computation.</p></div></div><pre><code class="language-julia hljs">using OrdinaryDiffEq

# Controls
u0 = 0                   # off control: vertical singular line
u1 = 1                   # positive bang control
us(y) = γ⋅(2Γ−γ)/(2δ⋅y)  # singular control: horizontal line

# Flows
options = (abstol=1e-14, reltol=1e-10)

f0 = Flow(ocp, (q, p, tf) -&gt; u0      ; options...)
f1 = Flow(ocp, (q, p, tf) -&gt; u1      ; options...)
fs = Flow(ocp, (q, p, tf) -&gt; us(q[1]); options...)</code></pre><p>With the previous flows, we can define the shooting function considering the sequence given by the direct method: Bang-Singular-Bang-Singular. There are 3 switching times <span>$t_1$</span>, <span>$t_2$</span> and <span>$t_3$</span>. The final time <span>$t_f$</span> is unknown such as the initial costate. To reduce the sensitivity of the shooting function we also consider the states and costates at the switching times as unknowns and we add some matching conditions.</p><p>Note that the final time is free, hence, in the normal case, <span>$H = -p^0 = 1$</span> along the solution of the PMP. Considering this condition at the initial time (<span>$H$</span> is constant since the system is autonomous), we obtain <span>$p_y(0) = -1$</span>. At the entrance of the singular arcs, we must satisfy <span>$H_1 = H_{01} = 0$</span>. For the first singular arc, this leads to the conditions </p><p class="math-container">\[    - p_y(t_1) z_s + p_z(t_1) y(t_1) = z(t_1) - z_s = 0.\]</p><p>At the entrance of the second singular arc, we have</p><p class="math-container">\[    p_y(t_3) = y(t_3) = 0.\]</p><p>Finally, the solution has to satisfy the final condition  <span>$q(t_f) = (y(t_f), z(t_f)) = (0, 0)$</span>. Since, the last singular arc is contained in <span>$y=0$</span>, the condition <span>$y(t_f)=0$</span> is redundant and  so we only need to check that <span>$z(t_f) = 0$</span>.</p><p>Altogether, this leads to the following shooting function.</p><pre><code class="language-julia hljs">function shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

    p0 = [-1, pz0]

    q1_, p1_ = f1(t0, q0, p0, t1)
    q2_, p2_ = fs(t1, q1, p1, t2)
    q3_, p3_ = f1(t2, q2, p2, t3)
    qf , pf  = f0(t3, q3, p3, tf)

    s[1] = - p1[1] ⋅ zs + p1[2] ⋅ q1[1]   # H1 = H01 = 0 on the horizontal
    s[2] = q1[2] - zs                     # singular line, z=zs
    s[3] = p3[1]                          # H1 = H01 = 0 on the vertical
    s[4] = q3[1]                          # singular line, y=0
    s[5] = qf[2]                          # z(tf) = 0

    # matching conditions
    s[ 6: 7] = q1 - q1_
    s[ 8: 9] = p1 - p1_
    s[10:11] = q2 - q2_
    s[12:13] = p2 - p2_
    s[14:15] = q3 - q3_
    s[16:17] = p3 - p3_

end</code></pre><p>We are now in position to solve the shooting equations. Due to the sensitivity of the first singular arc, we need to improve the initial guess obtained from the direct method to make the Newton solver converge. To do so, we set for the initial guess <span>$z(t_1) = z_s$</span> and <span>$p_z(t_1) = p_y(t_1) z_s / y(t_1)$</span>.</p><p>We can see below from the norm of the shooting function that the initial guess is not very accurate.</p><pre><code class="language-julia hljs"># we refine the initial guess to make the Newton solver converge
q1[2] = zs
p1[2] = p1[1] ⋅ zs / q1[1]

# Norm of the shooting function at initial guess
using LinearAlgebra: norm

s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)

println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Norm of the shooting function: ‖s‖ = 18.36155510048353</code></pre><p>We can use the <a href="https://github.com/sglyon/MINPACK.jl">MINPACK.jl</a> package to solve the shooting equation. To compute the Jacobian of the shooting function we use the <a href="https://juliadiff.org/DifferentiationInterface.jl/DifferentiationInterface">DifferentiationInterface.jl</a> package with <a href="https://juliadiff.org/ForwardDiff.jl">ForwardDiff.jl</a> backend.</p><pre><code class="language-julia hljs">using DifferentiationInterface
import ForwardDiff
backend = AutoForwardDiff()</code></pre><p>Let us define the problem to solve.</p><pre><code class="language-julia hljs"># auxiliary function with aggregated inputs
shoot!(s, ξ) = shoot!(s, ξ[1], ξ[2:5]..., ξ[6:7], ξ[8:9],
    ξ[10:11], ξ[12:13], ξ[14:15], ξ[16:17])

# Jacobian of the (auxiliary) shooting function
jshoot!(js, ξ) = jacobian!(shoot!, similar(ξ), js, backend, ξ)</code></pre><p>We are now in position to solve the problem with the <code>hybrj</code> solver from MINPACK.jl through the <code>fsolve</code> function, providing the Jacobian. Let us solve the problem and retrieve the initial contate and the times (switching and final) from the solution.</p><pre><code class="language-julia hljs">using MINPACK

# initial guess
ξ = [ pz0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3]

# resolution of S(ξ) = 0
indirect_sol = fsolve(shoot!, jshoot!, ξ, show_trace=true)

# we retrieve the costate solution together with the times
pz0 = indirect_sol.x[1]
t1 = indirect_sol.x[2]
t2 = indirect_sol.x[3]
t3 = indirect_sol.x[4]
tf = indirect_sol.x[5]
q1 = indirect_sol.x[6:7]
p1 = indirect_sol.x[8:9]
q2 = indirect_sol.x[10:11]
p2 = indirect_sol.x[12:13]
q3 = indirect_sol.x[14:15]
p3 = indirect_sol.x[16:17]

println(&quot;pz0 = &quot;, pz0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)

# Norm of the shooting function at solution
s = similar([pz0], 17)
shoot!(s, pz0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     f(x) inf-norm    Step 2-norm      Step time
------   --------------   --------------   --------------
     1     1.729122e+01     0.000000e+00         0.251969
     2     9.461468e-01     3.704268e+01        12.982782
     3     2.839417e-01     7.649105e+00         0.004512
     4     2.196746e-01     6.189414e+00         0.004543
     5     4.899687e-02     1.555075e+01         0.004560
     6     1.317601e-01     6.220299e+01         0.004548
     7     3.647552e-01     1.399561e+02         0.004622
     8     4.266673e-02     3.889313e+00         0.054794
     9     1.862372e-01     1.555075e+01         0.004506
    10     3.906691e-02     3.889347e+00         0.004481
    11     6.814071e-02     3.887687e+00         0.004553
    12     1.408918e-02     9.722099e-01         0.004551
    13     4.460910e-02     3.887687e+00         0.004601
    14     9.719317e-03     9.720021e-01         0.004523
    15     4.894523e-02     3.887687e+00         0.004569
    16     1.037975e-02     9.720452e-01         0.004554
    17     1.722110e-02     9.719218e-01         0.004513
    18     3.374491e-03     2.429959e-01         0.004493
    19     1.050803e-02     9.719218e-01         0.004665
    20     2.514214e-03     2.429847e-01         0.004753
    21     1.236260e-02     9.719218e-01         0.004799
    22     2.699892e-03     2.429877e-01         0.006220
    23     4.405108e-03     2.429804e-01         0.006479
    24     1.140801e-03     6.074605e-02         0.025256
    25     2.529561e-03     2.429804e-01         0.004604
    26     8.971382e-04     6.074537e-02         0.004555
    27     3.105367e-03     2.429804e-01         0.004526
    28     6.886897e-04     6.074555e-02         0.004524
    29     1.114999e-03     6.074511e-02         0.004583
    30     5.937321e-04     1.518634e-02         0.004577
    31     6.886842e-04     6.074511e-02         0.004590
    32     5.243157e-04     1.518629e-02         0.004560
    33     7.780882e-04     6.074511e-02         0.004584
    34     4.570424e-04     1.518630e-02         0.004552
    35     7.861590e-04     6.074511e-02         0.004584
    36     3.925009e-04     1.518631e-02         0.004579
    37     7.834904e-04     6.074511e-02         0.004596
    38     3.308893e-04     1.518631e-02         0.004570
    39     7.850448e-04     6.074511e-02         0.005850
    40     2.723456e-04     1.518631e-02         0.006473
    41     7.867550e-04     6.074511e-02         0.006678
    42     2.170459e-04     1.518631e-02         0.015331
    43     7.883591e-04     6.074511e-02         0.004453
    44     1.793299e-04     1.518631e-02         0.004446
    45     7.899762e-04     6.074511e-02         0.004494
    46     1.787759e-04     1.518631e-02         0.004578
    47     2.839177e-04     1.518628e-02         0.004569
    48     1.589777e-04     3.796573e-03         0.004560
    49     1.503008e-04     1.518628e-02         0.004531
    50     1.506639e-04     3.796570e-03         0.004671
    51     1.968768e-04     1.518628e-02         0.004942
    52     1.424838e-04     3.796571e-03         0.004592
    53     1.995271e-04     1.518628e-02         0.004605
    54     1.342526e-04     3.796571e-03         0.004600
    55     1.981819e-04     1.518628e-02         0.004518
    56     1.259568e-04     3.796571e-03         0.004491
    57     1.983571e-04     1.518628e-02         0.010916
    58     1.175940e-04     3.796571e-03         0.004499
    59     1.986120e-04     1.518628e-02         0.004523
    60     1.091543e-04     3.796571e-03         0.004481
    61     1.988165e-04     1.518628e-02         0.004533
    62     1.006264e-04     3.796571e-03         0.004560
    63     1.990215e-04     1.518628e-02         0.004594
    64     9.199661e-05     3.796571e-03         0.004574
    65     7.942206e-05     3.796569e-03         0.004518
    66     8.723075e-05     9.491426e-04         0.004660
    67     7.506888e-05     3.796569e-03         0.004558
    68     1.671472e-04     1.518628e-02         0.004551
    69     6.666612e-05     3.796571e-03         0.010323
    70     6.134116e-05     9.491423e-04         0.025129
    71     4.993156e-05     3.796569e-03         0.004534
    72     5.647321e-05     9.491424e-04         0.004478
    73     4.774483e-05     3.796569e-03         0.004640
    74     5.160140e-05     9.491424e-04         0.004523
    75     4.774429e-05     3.796569e-03         0.004576
    76     4.672439e-05     9.491424e-04         0.004570
    77     4.776050e-05     3.796569e-03         0.004558
    78     4.183994e-05     9.491424e-04         0.004548
    79     4.777702e-05     3.796569e-03         0.004545
    80     3.694529e-05     9.491424e-04         0.004568
    81     4.779396e-05     3.796569e-03         0.010193
    82     3.203693e-05     9.491424e-04         0.004451
    83     4.781135e-05     3.796569e-03         0.004484
    84     2.711017e-05     9.491424e-04         0.004556
    85     4.782922e-05     3.796569e-03         0.004549
    86     2.215861e-05     9.491424e-04         0.004613
    87     4.784748e-05     3.796569e-03         0.004544
    88     1.717278e-05     9.491424e-04         0.004508
    89     4.786617e-05     3.796569e-03         0.004513
    90     1.213744e-05     9.491424e-04         0.004575
    91     4.788528e-05     3.796569e-03         0.004634
    92     8.099733e-06     9.491424e-04         0.009828
    93     2.324556e-05     1.548720e-03         0.004530
    94     2.321022e-06     7.302766e-05         0.004462
    95     2.874309e-06     7.491451e-05         0.004516
    96     1.820500e-08     1.764248e-10         0.004497
    97     4.598817e-09     9.549517e-12         0.004559
    98     3.929525e-12     3.584306e-13         0.004567
pz0 = -10.103027162172827
t1 = 1.6450509469600774
t2 = 37.32398128558159
t3 = 37.580773578617254
tf = 42.713708753631714
Norm of the shooting function: ‖s‖ = 3.977038221381455e-12</code></pre><p>Let us plot the solution from the indirect method. We can notice that the second bang arc is well captured by the indirect method compared to the direct method.</p><pre><code class="language-julia hljs"># concatenation of the flows with the switching times
f = f1 * (t1, fs) * (t2, f1) * (t3, f0)

# computation of the solution: state, costate, control
indirect_sol = f((t0, tf), q0, [-1, pz0])

# plot in the Bloch ball
spin_plot(indirect_sol; size=(800, 400))</code></pre><img src="saturation-cd6fab57.svg" alt="Example block output"/><p>From the following plot, we can conclude that the maximisation condition from the PMP is now well satisfied compared to the solution obtained from the direct method.</p><pre><code class="language-julia hljs">plt = switching_plot(indirect_sol, H1, H01; size=(700, 800))
lens!(plt, [37.2, 37.7], [    0, 4e-5], inset = (1, bbox(0.3, 0.2, 0.3, 0.4)))
lens!(plt, [37.2, 37.7], [-5e-4, 5e-4], inset = (2, bbox(0.3, 0.3, 0.3, 0.4)))
lens!(plt, [37.2, 37.7], [  0.5,  1.1], inset = (3, bbox(0.3, 0.2, 0.3, 0.4)))</code></pre><img src="saturation-32db036d.svg" alt="Example block output"/><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>B. Bonnard, O. Cots, S. Glaser, M. Lapert, D. Sugny &amp; Y. Zhang, *Geometric optimal control of the contrast imaging problem in nuclear magnetic resonance, IEEE Trans. Automat. Control, <strong>57</strong> (2012), no. 8, 1957–1969.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Bonnard, B.; Cots, O.; Rouot, J.; Verron, T. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88. https://inria.hal.science/hal-01779377</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="bloch-equation.html">« Bloch equation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 31 October 2025 09:57">Friday 31 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
